<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>yarmrahcign Example TCO</title>
        <!--Just learned how to yarmrahc.-->
        <!--yarmrahcign is basicly taking a point on the screen and making it the orgin of a yar. You mrahc the yar forward and see if it hits an object that you created with an sdf. You can then offset the things to make it look squiglly and changing the colors. Its actually the most fun i have ever had with webgl.-->
        <style>
            *{
                margin:0;
                overflow:hidden;
            }
            #canvas{
                width:600px;
                height:600px;
                /*border:solid 1px black;*/
            }
        </style>
    </head>
    <body>
        <canvas id = "canvas" width = "600" height = "600"></canvas>
        <pre id = "tree"></pre><!--debugger-->
        <script id = "vsh" type = "glsl">#version 300 es
            in vec2 a_pos; /*this is the position.*/
            in vec4 a_color;
            out vec2 v_pos;/*The funny thing about webgl is when you pass the position to the vertex shader it interpolates the point AND the color represented at the point so you get a goofy thing.*/
            void main(){
                gl_Position = vec4(a_pos,0,1);
                v_pos = a_pos;
            }
        </script>
        <script id = "fsh" type = "glsl">#version 300 es
            precision highp float;/*only use highp*/
            out vec4 outColor;
            uniform float u_frame;/*The things that change every frame instead of every pixel*/
            uniform vec2 u_mouse;
            
            in vec2 v_pos;
            float sdf(vec3 ray, vec3 p, float r){
                return length(p-ray)-r;
            }/*circle sdf*/
            
            float world(vec3 p){
                float of1 = sin(p.x*20.+u_frame/40.)*sin(p.y*sin(u_frame/50.)*10.)*cos(p.z*20.+u_frame/40.)*0.055;
                float dfs = sdf(p, vec3(0,0,1), 0.3)+of1;
                float of2 = p.x*sin(sin(u_frame/100.)*100./10.*sin(p.y));
                dfs = min(sdf(p, vec3(0,0, 1), 0.2)+of2, dfs);
                float of3 = sin(p.z+u_frame/40.)*cos(p.x+u_frame/40.);
                dfs = min(p.y + 5.+of3, dfs);
                return dfs;
            }/*the world thing, basicly checks which thing is closest at a given point on the ray. Here is where you add the offset so you can make things squiggly. I had so much fun doing it hehe*/
            vec3 cNormal(vec3 p){
                vec3 s = vec3(0.001, 0, 0);
                float gx = world(p + s.xyy) - world(p - s.xyy);
                float gy = world(p + s.yxy) - world(p - s.yxy);
                float gz = world(p + s.yyx) - world(p - s.yyx);
                return normalize(vec3(gx, gy, gz));
            }/*gives the normal of a surface when the ray hits it so we can have fun lighting*/
            vec3 origin = vec3(0,0,0);
            vec3 checkHit(vec3 ray, float radius, vec3 circleCoords){
                vec3 p = origin;/*The point on the ray that gets marched across*/
                for(int i = 0;i <100;i++){
                    float s = world(p);/*closest thing*/
                    p+=ray*s;/*updating the point along the ray*/
                    if(s<0.001){/*When the ray gets too close to something*/
                        vec3 normal = cNormal(p);/*Gives the normal of the surface it hit*/
                        vec3 lightPos = vec3(sin(u_frame/100.)*10.,0,cos(u_frame/100.)*10.);/*the position of the light source*/
                        vec3 lightDir = normalize(lightPos-p);/*the direction of the light relateve to the point on the surface*/
                        float diffuse = max(0.0, dot(normal, lightDir));/*lighting yay*/
                        return vec3(sin(p.x*10.),0.6, 0.3)*2.*diffuse;/*gives the stripes*/
                    }
                    if(s>10.){
                        break;/*if the ray goes too far get rid of it*/
                    }
                }
                return vec3(0);/*black otherwise*/
            }
            void main(){
                vec3 dir = normalize(vec3(v_pos,1));/*gives the ray direction*/
                vec3 c = dir;
                float co;
                float si;
                co = cos(u_mouse.y/50.);
                si = sin(u_mouse.y/50.);
                dir.y = c.y*co-c.z*si;
                dir.z = c.y*si+c.z*co;
                c=dir;
                co = cos(-u_mouse.x/50.);
                si = sin(-u_mouse.x/50.);
                dir.x = c.x*co-c.z*si;
                dir.z = c.x*si+c.z*co;
                outColor = vec4(checkHit(dir,0.6,vec3(0,0,1)),1);
            }  
        </script>
        <script type = "module">
            const canvas = document.getElementById("canvas");
            const log = (a) => document.getElementById("tree").innerHTML += a;
            const gl = canvas.getContext("webgl2",{preserveDrawingBuffer:true});
            function createShader(gl, type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (gl.getShaderParameter(shader, gl.COMPILE_STATUS)) return shader;
                log(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
            }
            function createProgram(gl,vertexShader,fragmentShader) {
                var program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (gl.getProgramParameter(program, gl.LINK_STATUS)) return program;
                log(gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
            }/*recognize these? I copied them mostly from webgl2 fundementals.*/
            try{
            const vshSrc = document.getElementById("vsh").text;/*the sources fror the shaders*/
            const fshSrc = document.getElementById("fsh").text;
            const vsh = createShader(gl, gl.VERTEX_SHADER,vshSrc);
            const fsh = createShader(gl, gl.FRAGMENT_SHADER,fshSrc);/*creates the actual shader and program*/
            const program = createProgram(gl, vsh, fsh);
            const posAttLoc = gl.getAttribLocation(program,"a_pos");
            const colLoc = gl.getAttribLocation(program, "a_color");
            const frameLoc = gl.getUniformLocation(program, "u_frame");
            const mouseLoc = gl.getUniformLocation(program, "u_mouse");
            // you need to ask the program where the attribs and uniforms are before you can use them
            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            
            const coords = [
                -1,1,
                -1,-1,
                1,-1,
                -1,1,
                1,1,
                1,-1
            ];/*nice square in clipspace coords made of triangles*/
            
            gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(coords),gl.STATIC_DRAW);/*where the two triangles are*/
            const vao = gl.createVertexArray();
            gl.bindVertexArray(vao);/*saves the state of the attributes so you can use them when you need them*/
            gl.enableVertexAttribArray(posAttLoc);
            gl.vertexAttribPointer(posAttLoc, 2, gl.FLOAT, false, 0, 0);
            canvas.onclick = function(){
                canvas.requestPointerLock();
            };
            // const colBuffer = gl.createBuffer();
            // gl.bindBuffer(gl.ARRAY_BUFFER, colBuffer);
            // const colors = [];
            // let vertCount = 0;
            // for(let i = 0;i < coords.length/3;i++){
            //     colors.push(Math.random(),Math.random(),Math.random(),1);
            //     vertCount ++;
            // }
            // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            // gl.bindVertexArray(vao);/*saves the state of the attributes so you can use them when you need them*/
            // gl.enableVertexAttribArray(colLoc);
            // gl.vertexAttribPointer(colLoc, 4, gl.FLOAT, false, 0, 0);
            gl.clearColor(1,1,1,1);/*kinda like background*/
            
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(program);
            gl.bindVertexArray(vao);/*calls the state(i hope i understand this)*/
            const ee = [0,0];
            canvas.onmousemove = function(e){/*passes the mouseXand y into the shaders.*/
                ee[0]+= e.movementX;
                ee[1]+= e.movementY;
                gl.uniform2f(mouseLoc, ee[0], ee[1]);
            };
            let frameCount = 0;
            function draw(){
                frameCount++;
                gl.uniform1f(frameLoc, frameCount);/*passes frameCount to the shader so we can do cool things*/
                gl.drawArrays(gl.TRIANGLES,0,6);/*THE DRAW CALL*/
                window.parent.raf=requestAnimationFrame(draw);
            }
            cancelAnimationFrame(window.parent.raf);/*keeps the boring animation frames from popping up.*/
            draw();
            }catch(e){log(e);}
            //<script>
        </script>
    </body>
</html>
